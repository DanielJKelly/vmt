const controllers = require('./controllers')

const sockets = {};
sockets.init = server => {

    const io = require('socket.io')(server, {wsEngine: 'ws'});
    io.sockets.on('connection', socket => {
      socket.on('JOIN', (data, callback) => {
        socket.join(data.roomId, async () => {
          // update current users of this room
          const promises = [];
          if (data.tempRoom) {
            let rooms = [];
            let user;
            let room;
            // create a temp user
            try {
              user = await controllers.user.post({
                username: data.username,
                accountType: 'temp',
              })
            }
            catch(err) {console.log(err)}
            try {
              rooms = await controllers.room.get({tempId: data.roomId})
              room = await rooms[0].populate('events')
              // console.log(room)
            }
            catch(err) {console.log(err)}
            if (rooms.length === 0) {
              try {
                room = await controllers.room.post({
                  tempId: data.roomId,
                  name: data.roomName,
                  roomType: 'geogebra',
                  tempRoom: true,
                  members: [{user: user._id, role: 'student'}],
                  currentUsers: [user._id]
                })
              }
              catch(err) {console.log(err)}
            } else {
              try {
                room = await controllers.room.addCurrentUsers(room._id, user._id)
              }
              catch(err) {
                console.log("47: ",err)
              }
            }
            const message = {
              user: {_id: user._id, username: 'VMTbot'},
              room: room._id,
              text: `${data.username} joined ${data.roomName}`,
              autogenerated: true,
              timestamp: new Date().getTime(),
            }
            // THESE SHOULD NOT BE SEPERATE SOCKET EMITIONS
            io.in(data.roomId).emit('RECEIVE_MESSAGE', message)
            socket.broadcast.to(data.roomId).emit('USER_JOINED', {currentUsers: room.currentUsers, message,});
            console.log(room)
            callback({room, user}, null)
          }
          else {
            const message = {
              user: {_id: data.userId, username: 'VMTbot'},
              room: data.roomId,
              text: `${data.username} joined ${data.roomName}`,
              autogenerated: true,
              timestamp: new Date().getTime(),
            }
            promises.push(controllers.message.post(message))
            promises.push(controllers.room.addCurrentUsers(data.roomId, data.userId))
          }
          Promise.all(promises)
          .then(results => {
            io.in(data.roomId).emit('RECEIVE_MESSAGE', message)
            socket.broadcast.to(data.roomId).emit('USER_JOINED', {currentUsers: results[1].currentUsers, message,});
            callback({result: results[1].currentUsers}, null)
          })
          .catch(err => callback(null, err))
        })
      });
      socket.on('LEAVE', (data, callback) => {
        socket.leave(data.roomId, () => {
          const promises = [];
          const message = {
            user: {_id: data.userId, username: 'VMTbot'},
            room: data.roomId,
            text: `${data.username} left ${data.roomName}`,
            autogenerated: true,
            timestamp: new Date().getTime(),
          }
          promises.push(controllers.message.post(message))
          promises.push(controllers.room.removeCurrentUsers(data.roomId, data.userId))
          Promise.all(promises)
          .then(results => {
            console.log("room after disconnect: ",results[1]);
            io.in(data.roomId).emit('RECEIVE_MESSAGE', message)
            socket.broadcast.to(data.roomId).emit('USER_LEFT', {currentUsers: results[1].currentUsers, message,});
            callback({result: room.currentUsers})
          })
          .catch(err => console.log(err))
        })
      })
      socket.on('SEND_MESSAGE', (data, callback) => {
        const postData = {...data}
        postData.user = postData.user._id;
        controllers.message.post(postData)
        .then(res => {
          socket.broadcast.to(data.room).emit('RECEIVE_MESSAGE', data);
          callback('success', null)
        })
        .catch(err => {
          callback('fail', err)
          console.log(err)
        })
        // broadcast new message
      })

      socket.on('SEND_EVENT', (data) => {
        if (typeof data.event !== 'string') {
          data.event = JSON.stringify(data.event)
        }
        controllers.room.put(data.room, {currentState: data.currentState})
        delete data.currentState;
        controllers.event.post(data)
        socket.broadcast.to(data.room).emit('RECEIVE_EVENT', data)
      })
    });

}

module.exports = sockets;
