const controllers = require('./controllers')

const sockets = {};
sockets.init = server => {

    const io = require('socket.io')(server, {wsEngine: 'ws'});

    io.sockets.on('connection', socket => {
      socket.on('JOIN', async (data, callback) => {
        const promises = [];
        let user = data.user || null;
        if (data.tempRoom) {
          if (data.roomType) controllers.rooms.put(data.roomId, {roomType: data.roomType});
          user = await controllers.user.post({username: data.username,accountType: 'temp',});
          data.userId = user._id;
          user = {_id: user._id, username: data.username,}
        }
        user.socketId = socket.id;
        socket.join(data.roomId, async () => {
          // update current users of this room
          const message = {
            user: {_id: data.userId, username: 'VMTbot'},
            room: data.roomId,
            text: `${data.username} joined ${data.roomName}`,
            autogenerated: true,//
            timestamp: new Date().getTime(),
          }
          promises.push(controllers.messages.post(message))
          promises.push(controllers.rooms.addCurrentUsers(data.roomId, {user: data.userId, socket: socket.id})) //
          let results;
          try {
            results = await Promise.all(promises)
          }
          catch(err) {
            return callback(null, err)
          }
          socket.to(data.roomId).emit('USER_JOINED', {currentUsers: results[1].currentUsers, message,});
          let room = {...results[1]}
          // room.chat.push(message)
          callback({room: results[1], message, user,}, null)
            // io.in(data.roomId).emit('RECEIVE_MESSAGE', message)
        })
      });

      
      // socket.on('LEAVE', (data, callback) => {
      //   console.log('disconnected!')
      //   // console.log(data)
      //   socket.leave(data.roomId, () => {
      //     let promises = [];
      //     let message = {
      //       user: {_id: data.userId, username: 'VMTbot'},
      //       room: data.roomId,
      //       text: `${data.username} left ${data.roomName}`,
      //       autogenerated: true,
      //       timestamp: new Date().getTime(),
      //     }
      //     promises.push(controllers.messages.post(message))
      //     promises.push(controllers.rooms.removeCurrentUsers(data.roomId, data.userId))
      //     Promise.all(promises)
      //     .then(results => {
      //       console.log("room after disconnect: ",results[1]);
      //       // io.in(data.roomId).emit('RECEIVE_MESSAGE', message)
      //       socket.broadcast.to(data.roomId).emit('USER_LEFT', {currentUsers: results[1].currentUsers, message,});
      //       // callback({result: room.currentUsers})
      //     })
      //     .catch(err => console.log(err))
      //   })
      // })
      socket.on('disconnecting', () => {
        rooms = Object.keys(socket.rooms).slice(1)
        rooms.forEach(async (room) => {
          controllers.rooms.removeCurrentUsers(room, socket.id)
          .then(res => {
            console.log("CALLBACK FROM DB OPERATION")
            console.log(res)
            socket.to(room).emit('USER_LEFT', {currentUsers: res.currentUsers, message: 'someone left'})
          })
        })
      })

      socket.on('disconnect', () => {
        console.log("ROOMS ON DICONNECT: ", socket.rooms)
        console.log(socket.id, ' disconnected')
        // let message = {
        //   user: {_id: data.userId, username: 'VMTbot'},
        //   room: data.roomId,
        //   text: `${data.username} left ${data.roomName}`,
        //   autogenerated: true,
        //   timestamp: new Date().getTime(),
        // }

      })

      socket.on('SEND_MESSAGE', (data, callback) => {
        const postData = {...data}
        postData.user = postData.user._id;
        controllers.messages.post(postData)
        .then(res => {
          socket.broadcast.to(data.room).emit('RECEIVE_MESSAGE', data);
          callback('success', null)
        })
        .catch(err => {
          callback('fail', err)
          console.log(err)
        })
        // broadcast new message
      })

      socket.on('SEND_EVENT', (data) => {
        if (typeof data.event !== 'string') {
          data.event = JSON.stringify(data.event)
        }
        controllers.rooms.put(data.roomId, {currentState: data.currentState})
        delete data.currentState;
        controllers.events.post(data)
        socket.broadcast.to(data.room).emit('RECEIVE_EVENT', data)
      })
    });

}

module.exports = sockets;
