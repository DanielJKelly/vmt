const controllers = require('./controllers')

const sockets = {};
sockets.init = server => {

    const io = require('socket.io')(server, {wsEngine: 'ws'});
    io.sockets.on('connection', socket => {
      socket.on('JOIN', async (data, callback) => {
        let user = data.user || null;
        let room;
        let userAlreadyAdded;
        if (data.tempRoom) {
          try {
            user = await controllers.user.post({
              username: data.username,
              accountType: 'temp',
            })
            data.userId = user_id;
          }
          catch(err) {console.log(err)}
          if (!data.roomId) {
            userAlreadyAdded = true;
            try {
              room = await controllers.room.post({
                roomType: 'geogebra',
                tempRoom: true,
                // members: [{user: user._id, role: 'student'}],
                // currentUsers: [user._id]
              })
            }
            catch(err) {console.log(err)}
            data.roomId = room._id;
            data.roomName = `temporary room ${room.id.slice(0, 5)}...`
          }
        }
        console.log("data.roomId: ", data.roomId)
        socket.join(data.roomId, () => {
          // update current users of this room
          const message = {
            user: {_id: data.userId, username: 'VMTbot'},
            room: room._id,
            text: `${data.username} joined ${data.roomName}`,
            autogenerated: true,
            timestamp: new Date().getTime(),
          }
          const promises = [];
          promises.push(controllers.message.post(message))
          promises.push(controllers.room.addCurrentUsers(data.roomId, data.userId)) //
          Promise.all(promises)
          .then(results => {
            // io.in(data.roomId).emit('RECEIVE_MESSAGE', message)
            socket.broadcast.to(data.roomId).emit('USER_JOINED', {currentUsers: results[1].currentUsers, message,});
            callback({result: results[1].currentUsers}, null)
          })
          .catch(err => callback(null, err))
        })
      });
      socket.on('disconnect', (data, callback) => {
        console.log('disconnected!')
        socket.leave(data.roomId, () => {
          const promises = [];
          const message = {
            user: {_id: data.userId, username: 'VMTbot'},
            room: data.roomId,
            text: `${data.username} left ${data.roomName}`,
            autogenerated: true,
            timestamp: new Date().getTime(),
          }
          promises.push(controllers.message.post(message))
          promises.push(controllers.room.removeCurrentUsers(data.roomId, data.userId))
          Promise.all(promises)
          .then(results => {
            console.log("room after disconnect: ",results[1]);
            // io.in(data.roomId).emit('RECEIVE_MESSAGE', message)
            socket.broadcast.to(data.roomId).emit('USER_LEFT', {currentUsers: results[1].currentUsers, message,});
            // callback({result: room.currentUsers})
          })
          .catch(err => console.log(err))
        })
      })
      socket.on('SEND_MESSAGE', (data, callback) => {
        const postData = {...data}
        postData.user = postData.user._id;
        controllers.message.post(postData)
        .then(res => {
          socket.broadcast.to(data.room).emit('RECEIVE_MESSAGE', data);
          callback('success', null)
        })
        .catch(err => {
          callback('fail', err)
          console.log(err)
        })
        // broadcast new message
      })
      socket.on('SEND_EVENT', (data) => {
        if (typeof data.event !== 'string') {
          data.event = JSON.stringify(data.event)
        }
        controllers.room.put(data.roomId, {currentState: data.currentState})
        delete data.currentState;
        controllers.event.post(data)
        console.log("BROADCASTING ", data)
        socket.broadcast.to(data.room).emit('RECEIVE_EVENT', data)
      })
    });

}

module.exports = sockets;
