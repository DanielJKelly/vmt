import React, { Component } from 'react';
// import TextInput from '../Form/TextInput/TextInput';
import classes from './chat.css';
// import Button from '../UI/Button/Button';
import SendIcon from './sendicon';
import moment from 'moment';
class Chat extends Component {

  state = {
    chatReferenceElement: null,
  }
  
  chatContainer = React.createRef()
  chatInput = React.createRef()
  chatEnd = React.createRef()
  
  componentDidMount() {
    window.addEventListener('resize', this.updateReference)
    window.addEventListener('keypress', this.onKeyPress)
    if (!this.props.replayer) this.chatInput.current.focus();
    this.scrollToBottom();
  }

  componentDidUpdate(prevProps){
    if (prevProps.messages.length !== this.props.messages.length) {
      this.scrollToBottom();
    }
    else if (!prevProps.referencing && this.props.referencing) {
      this.props.setChatCoords(this.getRelativeCoords(this.chatInput.current))
    } 
    else if (!prevProps.referenceElement && this.props.referenceElement && this.props.referencing) {
      this.chatInput.current.focus();
    }
  }
  
  componentWillUnmount() {
    window.removeEventListener('keypress', this.onKeyPress)
    window.removeEventListener('resize', this.updateReference)
  }

  onKeyPress = (event) => {
    if (event.key === 'Enter') {
      this.props.submit();
    }
  }

  updateReference = () => {
    if (this.props.showingReference || this.props.referencing) {
      this.props.setChatCoords(this.getRelativeCoords(this.state.chatReferenceElement))
    }
  }

  scrollToBottom = () => {
    this.chatEnd.current.scrollTop = this.chatEnd.current.scrollHeight;
    // window.scroll({top: this.containerRef.current.offsetTop - 100, left: 0, behavior: 'smooth'})
  }

  showReference = (event, reference) => {
    // If we're already showing this reference clear the reference
    if (this.props.showReference && this.props.referenceElement && (reference.element === this.props.referenceElement.element)) {
      this.props.clearReference()
    } else {
      this.props.showReference(reference, this.getRelativeCoords(event.target))
    }
  }

  getRelativeCoords = (target) => {
    this.setState({chatReferenceElement: target})
    let inputCoords = target.getBoundingClientRect();
    let parentCoords = target.offsetParent.getBoundingClientRect()
    let containerCoords = this.chatEnd.current.getBoundingClientRect()
    console.log(containerCoords)
    let left = containerCoords.left - parentCoords.left
    let top = inputCoords.top - parentCoords.top;
    return ({left, top,})
  }

  setChatReference = (event) => {
    console.log('setting chat reference')
    let position = this.getRelativeCoords(event.target);
    console.log(position)
    this.props.setReferenceElAndCoords({element: event.target, elementType: 'chat_message'}, position)
  }
  
  render() {
    const {messages, replayer, change, submit, value, referencing} = this.props;
    let displayMessages = [];
    if (messages) {
      displayMessages = messages.map((message, i) => {
        return (
          <div 
            key={i} 
            className={message.autogenerated ? classes.VmtBotEntry : classes.Entry } 
            onClick={
              message.reference ? (event) => this.showReference(event, message.reference) : 
              referencing ? this.setChatReference : null 
            }
            style={{cursor: message.reference || this.props.referencing ? 'pointer' : 'auto'}}
          >
            <div><b>{message.autogenerated ? 'VMTbot': message.user.username}: </b><span>{message.text}</span></div>
            {/* CONSIDER CONDITIONALLLY FORMATIING THE DATE BASED ON HOW FAR IN THE PAST IT IS
            IF IT WAS LAST WEEK, SAYING THE DAY AND TIME IS MISLEADING */}
            <div className={classes.Timestamp}>
              {moment.unix(message.timestamp/1000).format('ddd h:mm:ss a')}
            </div>
          </div>
        )
      })
      // use this to scroll to the bottom
      // displayMessages.push(<div key='end' ref={this.chatEnd}></div>)
    }
    return (
      <div className={classes.Container} ref={this.chatContainer}>
        <h3 className={classes.Title}>Chat</h3>
        <div className={classes.ChatScroll} ref={this.chatEnd} id='scrollable'>{displayMessages}</div>
        {!replayer ?
          <div className={classes.ChatInput}>
            <input ref={this.chatInput} className={classes.Input} type = {"text"} onChange={change} value={value}/>
            {/* <TextInput width={"90%"} size={20} light autoComplete="off" change={change} type='text' name='message' value={value}/> */}
            <div className={classes.Send} onClick={submit}>
              <SendIcon height='24' width='24' viewBox='0 0 24 24'/>
              </div>
          </div> : null
        }
      </div>
    )
  }
}

export default Chat;
